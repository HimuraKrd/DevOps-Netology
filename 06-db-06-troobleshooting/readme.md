# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.  

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать. Вы как инженер поддержки решили произвести данную операцию:
* напишите список операций, которые вы будете производить для остановки запроса пользователя
* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Согласно [документации](https://docs.mongodb.com/manual/tutorial/terminate-running-operations/) MongoDB, я сначала найду нужный процесс, используя ``db.currentOp()``, а затем остановлю его, используя ```db.killOp("shard_id:opid")```. Воспользуюсь инструментом мониторинга состояния ДБ (```db.enableFreeMonitoring()```) попытаюсь проанализировать, с чем связаны зависания CRUD процессов. Дальнейшие шаги будут зависеть от того, где именно будет выявлена ошибка. Возможно, придётся оптимизировать запросы, используя соответствующие разделы документации, например, [вот этот](https://docs.mongodb.com/manual/core/query-optimization/). Также если запрос пользователя максимльно большой, можно попытаться разбить его на более мелкие и проверить, как в данном случае пройдёт обработка.


## Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.  

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса. При масштабировании сервиса до N реплик вы увидели, что:
* сначала рост отношения записанных значений к истекшим
* Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?  

Есть вероятность того, что Redis не хватает ресурсов. В связи с этим могут возникать ошибки с AOF. Необходимо проверить ресурсы как сервера, где работает Redis, так и всех узлов, с которыми у нас происходит синхронизация. Необходимо:
* проверить Redis на наличие блокирующих slow команд: ``redis- cli SLOWLOG GET N``
* проверить и отключить huge_page на уровне ядра: ```echo never > /sys/kernel/mm/transparent_hugepage/enabled && \ systemctl restart redis```
* проверить задержку на уровне VM: ``` redis-cli --intrinsic-latency 100 ```


## Задача 3
Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.  

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
``` InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '```
* Как вы думаете, почему это начало происходить и как локализовать проблему?
* Какие пути решения данной проблемы вы можете предложить?

Нужно проверить все (3) возможные места ошибок, согласно [данной документации](https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html):
* увеличить параметр ``` net_read_timeout ``` с значений по-умолчанию (30) 
* проверить состояние ```SHOW GLOBAL STATUS LIKE 'Aborted_connects'``` в динамике. Если счётчик увеличивается - надо попробовать увеличить значение параметра ```  connect_timeout ```
* проверить логи на наличие ошибок вида ``` ER_NET_PACKET_TOO_LARGE ```. Если такие имеются - увеличить значение параметра ``` max_allowed_packet ```.


# Задача 4
Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.  

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL. После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
```postmaster invoked oom-killer```
* Как вы думаете, что происходит?
* Как бы вы решили данную проблему?

OOM killer - Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС. В данном случае надо провести "тюнинг" базы данных (при кейсе, в котором на сервере ничего кроме PostgreSQL нет) и оптимизировать её. Если это не помогло - необходимо выделить больше ресурсов на сервер баз данных.
