## 1. Какой системный вызов делает команда ``cd``? В прошлом ДЗ мы выяснили, что ``cd`` не является самостоятельной программой, это ``shell builtin``, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить ``strace на /bin/bash -c 'cd /tmp'``. В этом случае вы увидите полный список системных вызовов, которые делает сам ``bash`` при старте. Вам нужно найти тот единственный, который относится именно к ``cd``.  

![task_1](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/1.png)  
Я так и не понял смысла задания и принципа работы strace... Получается, надо просто просматривать весь результат вывода и искать нужные строки? Если так, то ответом на задание будет ``chdir("temp")``.  


## 2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
``vagrant@netology1:~$ file /dev/tty``
``/dev/tty: character special (5/0)``
``vagrant@netology1:~$ file /dev/sda``
``/dev/sda: block special (8/0)``
``vagrant@netology1:~$ file /bin/bash``
``/bin/bash: ELF 64-bit LSB shared object, x86-64``
## Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
Я ОЧЕНЬ долго сравнивал файлы и единственным общим, что я нашёл, было обращение к ``magic``:  
![task_2](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/2.png)  
Предположу, что это или ``openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`` или ``openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3``.  
Прошу помощи с этим заданием. Я не понимаю алгоритм, как решать подобные задачи...


## 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
Сделаем ``top > proverka``. В другом терминале откроем сессию и через lsof увидим, что есть файл, в который пишется результат: 
![task_3_1](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/3.1%20-%20lsof.png)  
И он постоянно растёт:  
![task_3_1-file-size](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/3.1%20-%20file%20size%20growing.png)  
Удалим файл, используя команду ``rm proverka``.
![task_3_1_lsof_deleted](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/3.1%20-%20lsof%20deleted.png)  
Попробуем открыть процесс, зная PID из команды выше ``nano /proc/1279/fd/1``. Используем ``/fd/1``, так как перенаправляем ``stdout`` (1) в файл proverka.  
![task_3_1](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/3.1%20-%20cat%20file.png)  
Гугл подсказал, что одним и способов обнуления файла является контрукция ``cat /dev/null > /proc/1279/fd/1``. 


## 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Нет, не занимают. 


## 5. В iovisor BCC есть утилита opensnoop
``root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop``
``/usr/sbin/opensnoop-bpfcc``
## На какие файлы вы увидели вызовы группы ``open`` за первую секунду работы утилиты? Воспользуйтесь пакетом ``bpfcc-tools`` для Ubuntu 20.04. 
![task_5](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/5.png)  
К сожалению, я не уверен, что понял задачу правильно... Если это не то, что требуется - укажите, пожалуйста, в комментариях :-)  

## 6. Какой системный вызов использует ``uname -a``? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в ``/proc``, где можно узнать версию ядра и релиз ОС.
Выполняем ``strace uname``  
![task_6_strace_uname](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/6%20-%20strace.png)  
И находим в нём строку:  
``uname({sysname="Linux", nodename="vagrant", ...}) = 0``  
Затем выполняем ``man proc`` (либо через ``| grep version``) и находим:  
![task_6](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/6.png)  
И видим на 2833 строке нужныый ответ (надеюсь..)
В ``man`` по ``uname`` была информация, что есть ещё ``uname(2)``, но как бы я не старался, у меня не получилось вызвать мануал, но в интернете нашёл следующую инфу, которая также может быть ответом на вопрос:  
``       Part of the utsname information is also accessible via
       /proc/sys/kernel/{ostype, hostname, osrelease, version,
       domainname}.``  

# 7. Чем отличается последовательность команд через ; и через && в bash? Например
``root@netology1:~# test -d /tmp/some_dir; echo Hi``
``Hi``
``root@netology1:~# test -d /tmp/some_dir && echo Hi``
``root@netology1:~#``
#Есть ли смысл использовать в bash &&, если применить set -e?
Отличие заключается в том, что параметры, введённые после ``&&`` будут выполнены лишь в случае возвращения кода выхода (0) команды до ``&&``. В случае с ``;`` такое ограничение отсутствует. В примере выше отсутствует директория ``/temp/some_dir`` и ``test`` выдаёт stderr.  
Если посмотреть на второй вопрос, то ``set -e`` автоматически завершает выполнение файла, если на получает не нулевой код выхода (нашёл в интернете....). Я думаю, его использование вполне логично при использовании циклов. В таком случае цикл не будет уходить в петлю вслучае ошибки, а программа будет завершаться.


# 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
-e завершает работу, если команда, лист или составная команда выдает ненулевой статус вывода.
-u считывает неустановленные переменные и специальне символы (кроме @ и * ) и завершает программу возвращая ненулевой результат.
-x подставляет значения переменных (команды, case, select, арифметических и т.д.) и выводит значение переменной PS4
-o pipefail устанавливает значение пайплайна на поселднее (самое правое) выражение, с ненулевым кодом или выходит, в случае успешного выполнения всех введённых команд.  

Я думаю, использование данных параметров спасёт от зацикливания и позволит исключить ошибки ввода (например, спецсимволов), что должно оказать положительное влияние на работу программ.

# 9. Используя ``-o stat`` для ``ps``, определите, какой наиболее часто встречающийся статус у процессов в системе. В ``man ps`` ознакомьтесь ``(/PROCESS STATE CODES)`` что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать ``S``, ``Ss`` или ``Ssl`` равнозначными).
Используя ``man``к ``ps`` и гугл, нашёл параметры ``-axo``, отображающие все статусы процессов. Список состояния процессов изображён ниже:  
![task_9](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/9_process_state_code.png)  
Итого получаем:  
![task_9_result](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%201)/images/9_result.png)  
Больше всего процессов ``S - interruptible sleep``.
