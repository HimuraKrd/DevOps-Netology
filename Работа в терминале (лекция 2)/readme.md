## 1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
![task_1](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/type%20cd.png)  
Команда cd относится к встроенным командам оболочки и без неё работать не может. Остальную часть вопроса, к сожалению, не понял :-(

## 2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
Поиск по ``man wc -l``  выдал информацию, что данная команда, с аттрибутом ``-l``, используется для вывода количества вхождений того, что мы передаём в strout grep-а. У grep есть собственный параметр, отвечающий за аналогичный вывод ``-c``. Для примера создадим файл и заполним его информацией.   
![task_2_1](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/2.1%20grep%20sample1.png)  
Поищем при помощи ``grep`` попадение по ``line`` и сравним результаты  
![task_2_2](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/2.1%20grep%20sample2.png) 

## 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
Выполним ``pstree -p`` и получим результат systemd(1)  
![task_2_2](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/2.1%20grep%20sample2.png) 

## 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
``ls /non_existing_folder 2> /dev/pts/#``  
stderr имеет параметр 2, поэтому нам необходимо имитировать ошибку. В примере выше мы пытаемся посмотреть содержимое файла несуществующей директории (получаем ошибку для вывода) и перенаправляем вывод на другую сессию ``/dev/pts/номер``. Номер сессии можно узнать, используя команду ``who am i``.

## 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
``less < original_file > new_file``  
Мы перехватываем ввод (stdin) ``less`` у исходного файла и перенаправляем в новый.


## 6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
Да, конечно :) Больше деталей на скриншоте :)  
![task_6](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/6.png)


## 7. Выполните команду ``bash 5>&1``. К чему она приведет? Что будет, если вы выполните ``echo netology > /proc/$$/fd/5``? Почему так происходит?
Выполнение данной команды приведёт к созданию нового "дискриптора" 5, в который будет выведет поток вывода (stdout). Вторая команда аналогична ``echo netology``, и выводит поток дискриптора 5.  
![task7](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/7.png)


## 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от ``|`` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
Воспользуемя потоком 5, созданным в задании 7. Перенаправим вывод следующим образом: в поток 5 мы перенаправляем ``stdout``, ``stdin`` перенаправляем в ``stderr``, а ``stderr`` в вновь созданный поток 5. Если мы вызовем какую-нибудь ошибку > результат (stderr) будет записан в файл, при этом мы получим отображение ошибки на экране :
![task_8.1](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/8.1.png)  
![task_8.1](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/8.2.png)


## 9. Что выведет команда ``cat /proc/$$/environ``? Как еще можно получить аналогичный по содержанию вывод?
Описанная команда выведет данные окружения ``env``. Аналогичный вывод можно получить, если выполнить следующую команду ``env | tr '\n' -d > [file_name]``


## 10. Используя ``man``, опишите что доступно по адресам ``/proc/<PID>/cmdline``, ``/proc/<PID>/exe``.


## 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью ``/proc/cpuinfo``.
Самая старшая версия 4_2. Можно искать через grep SSE с флагом ``-i``
![task11](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/11.png)

## 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.   
Однако:  
``vagrant@netology1:~$ ssh localhost 'tty'``
``not a tty``  
Почитайте, почему так происходит, и как изменить поведение.  
Насколько я понял логику задания - мы должны из виртуальной машины (интерфейс tty) должны ввести команду ``ssh localhost 'tty``. Только так у меня получилось добиться вывода ``not a tty``. Если я правильно понимаю суть задания - при попытке установить ssh соединение мы используем PTY, а ну TTY. Чтобы избежать ошибки можно убрав ``tty`` > тогда соединение будет устанавливаться по ssh и будет зайдействован PTY > соединение будет установлено корректно.
![task_12](https://github.com/HimuraKrd/devops-netology/blob/main/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%B2%20%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B5%20(%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%202)/images/12.png)

## 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись ``reptyr``. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.


## 14. ``sudo echo string > /root/new_file`` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без ``sudo`` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию ``echo string | sudo tee /root/new_file``. Узнайте что делает команда ``tee`` и почему в отличие от ``sudo echo`` команда с ``sudo tee`` будет работать.
``tee`` используется для перенаправления потока ввода в вывод. 
